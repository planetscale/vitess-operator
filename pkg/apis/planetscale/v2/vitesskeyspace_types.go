/*
Copyright 2019 PlanetScale Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v2

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
//
// Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// VitessKeyspace represents the deployment of a logical database in Vitess.
// Each keyspace consists of a number of shards, which then consist of tablets.
// The tablets belonging to one VitessKeyspace can ultimately be deployed across
// various VitessCells.
// +k8s:openapi-gen=true
// +kubebuilder:resource:path=vitesskeyspaces,shortName=vtk
// +kubebuilder:subresource:status
type VitessKeyspace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   VitessKeyspaceSpec   `json:"spec,omitempty"`
	Status VitessKeyspaceStatus `json:"status,omitempty"`
}

// VitessKeyspaceSpec defines the desired state of a VitessKeyspace.
// +k8s:openapi-gen=true
type VitessKeyspaceSpec struct {
	// VitessKeyspaceTemplate contains the user-specified parts of VitessKeyspaceSpec.
	// These are the parts that are configurable inside VitessCluster.
	// The rest of the fields below are filled in by the parent controller.
	VitessKeyspaceTemplate `json:",inline"`

	// GlobalLockserver are the params to connect to the global lockserver.
	GlobalLockserver VitessLockserverParams `json:"globalLockserver"`

	// Images are not customizable by users at the keyspace level because version
	// skew across the cluster is discouraged except during rolling updates,
	// in which case this field is automatically managed by the VitessCluster
	// controller that owns this VitessKeyspace.
	Images VitessKeyspaceImages `json:"images,omitempty"`

	// ImagePullPolicies are inherited from the VitessCluster spec.
	ImagePullPolicies VitessImagePullPolicies `json:"imagePullPolicies,omitempty"`

	// ZoneMap is a map from Vitess cell name to zone (failure domain) name
	// for all cells defined in the VitessCluster.
	ZoneMap map[string]string `json:"zoneMap"`

	// BackupLocations are the backup locations defined in the VitessCluster.
	BackupLocations []VitessBackupLocation `json:"backupLocations,omitempty"`

	// BackupEngine specifies the Vitess backup engine to use, either "builtin" or "xtrabackup".
	BackupEngine VitessBackupEngine `json:"backupEngine,omitempty"`

	// ExtraVitessFlags is inherited from the parent's VitessClusterSpec.
	ExtraVitessFlags map[string]string `json:"extraVitessFlags,omitempty"`

	// TopologyReconciliation is inherited from the parent's VitessClusterSpec.
	TopologyReconciliation *TopoReconcileConfig `json:"topologyReconciliation,omitempty"`

	// UpdateStrategy is inherited from the parent's VitessClusterSpec.
	UpdateStrategy *VitessClusterUpdateStrategy `json:"updateStrategy,omitempty"`
}

// VitessKeyspaceTemplate contains only the user-specified parts of a VitessKeyspace object.
type VitessKeyspaceTemplate struct {
	// Name is the keyspace name as it should be provided to Vitess.
	// Note that this is different from the VitessKeyspace object's
	// metadata.name, which is generated by the operator.
	//
	// WARNING: DO NOT change the name of a keyspace that was already deployed.
	// Keyspaces cannot be renamed, so this will be interpreted as an
	// instruction to delete the old keyspace and create a new one.
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=25
	// +kubebuilder:validation:Pattern=^[a-z0-9]([a-z0-9]*[a-z0-9])?$
	Name string `json:"name"`

	// Partitionings specify how to divide the keyspace up into shards by
	// defining the range of keyspace IDs that each shard contains.
	// For example, you might divide the keyspace into N equal-sized key ranges.
	//
	// Note that this is distinct from defining how each row maps to a keyspace ID,
	// which is done in the VSchema. Partitioning is purely an operational concern
	// (scaling the infrastructure), while VSchema is an application-level concern
	// (modeling relationships between data). This separation of concerns allows
	// resharding to occur generically at the infrastructure level without any
	// knowledge of the data model.
	//
	// Each partitioning must define a set of shards that fully covers the
	// space of all possible keyspace IDs; there can be no gaps between ranges.
	// There's usually only one partitioning present at a time, but during
	// resharding, it's necessary to launch the destination shards alongside
	// the source shards. When the resharding is complete, the old partitioning
	// can be removed, which will turn down (undeploy) any unneeded shards.
	//
	// If only some shards are being split or joined during resharding,
	// the shards that aren't changing must be specified in both partitionings,
	// although the common shards will be shared (only deployed once).
	// If the per-shard configuration differs, the configuration in the latter
	// partitioning (in the order listed in this field) will be used.
	// For this reason, it's recommended to add new partitionings at the end,
	// and only remove partitionings from the beginning.
	//
	// This field is required. An unsharded keyspace may be specified as a
	// partitioning into 1 part.
	// +kubebuilder:validation:MinItems=1
	// +kubebuilder:validation:MaxItems=2
	Partitionings []VitessKeyspacePartitioning `json:"partitionings"`

	// TurndownPolicy specifies what should happen if this keyspace is ever
	// removed from the VitessCluster spec. By default, removing a keyspace
	// entry from the VitessCluster spec will NOT actually turn down the
	// deployed resources, unless it can be verified that the keyspace was
	// previously set to have 0 total desired tablets across all shards.
	//
	// With this default policy (RequireIdle), before removing the keyspace
	// entry from the spec, you must first edit the keyspace entry to remove
	// all tablet pools from all shards, and wait for that change to roll out.
	// If a keyspace entry is removed too soon, the keyspace resources will
	// remain deployed indefinitely, and the keyspace will be listed in the
	// orphanedKeyspaces field of VitessCluster status.
	//
	// This is a safety mechanism to prevent accidental edits to the cluster
	// object from having immediate, destructive consequences. If the cluster
	// spec is only ever edited by automation whose edits you trust to be safe,
	// you can set the policy to Immediate to skip these checks.
	//
	// Default: RequireIdle
	// +kubebuilder:validation:Enum=RequireIdle,Immediate
	TurndownPolicy VitessKeyspaceTurndownPolicy `json:"turndownPolicy,omitempty"`
}

// VitessKeyspaceTurndownPolicy is the policy for turning down a keyspace.
type VitessKeyspaceTurndownPolicy string

const (
	// VitessKeyspaceTurndownPolicyRequireIdle specifies that keyspace may only
	// be turned down if they are idle; that is, if they have no resources
	// deployed.
	VitessKeyspaceTurndownPolicyRequireIdle VitessKeyspaceTurndownPolicy = "RequireIdle"
	// VitessKeyspaceTurndownPolicyImmediate specifies that removing a keyspace
	// from the VitessCluster spec should immediately trigger turn-down of
	// all resources previously deployed for the keyspace.
	VitessKeyspaceTurndownPolicyImmediate VitessKeyspaceTurndownPolicy = "Immediate"
)

// VitessKeyspaceImages specifies container images to use for this keyspace.
type VitessKeyspaceImages struct {
	/*
		***ATTENTION***

		Make sure to keep the following up to date if you add fields here:
		  * DefaultVitessKeyspaceImages() in vitesskeyspace_defaults.go
	*/

	// Vttablet is the container image (including version tag) to use for Vitess Tablet instances.
	Vttablet string `json:"vttablet,omitempty"`
	// Vtbackup is the container image (including version tag) to use for Vitess Backup jobs.
	Vtbackup string `json:"vtbackup,omitempty"`
	// Mysqld specifies the container image to use for mysqld, as well as
	// declaring which MySQL flavor setting in Vitess the image is
	// compatible with. Only one flavor image may be provided at a time.
	// mysqld running alongside each tablet.
	Mysqld *MysqldImage `json:"mysqld,omitempty"`
	// MysqldExporter specifies the container image for mysqld-exporter.
	MysqldExporter string `json:"mysqldExporter,omitempty"`
}

// VitessKeyspacePartitioning defines a set of shards by dividing the keyspace into key ranges.
// Each field is a different method of dividing the keyspace. Only one field should be set on
// a given partitioning.
type VitessKeyspacePartitioning struct {
	// Equal partitioning splits the keyspace into some number of equal parts,
	// assuming that the keyspace IDs are uniformly distributed, for example
	// because they're generated by a hash vindex.
	Equal *VitessKeyspaceEqualPartitioning `json:"equal,omitempty"`

	// Custom partitioning lets you explicitly specify the key range of every shard,
	// in case you don't want them to be divided equally.
	Custom *VitessKeyspaceCustomPartitioning `json:"custom,omitempty"`
}

// VitessKeyspaceEqualPartitioning splits the keyspace into some number of equal parts.
type VitessKeyspaceEqualPartitioning struct {
	// Parts is the number of equal parts to split the keyspace into.
	// If you need shards that are not equal-sized, use custom partitioning instead.
	//
	// Note that if the number of parts is not a power of 2, the key ranges will
	// only be roughly equal in size.
	//
	// WARNING: DO NOT change the number of parts in a partitioning after deploying.
	//          That's effectively deleting the old partitioning and adding a new one,
	//          which can lead to downtime or data loss. Instead, add an additional
	//          partitioning with the desired number of parts, perform a resharding
	//          migration, and then remove the old partitioning.
	// +kubebuilder:validation:Minimum=1
	Parts int32 `json:"parts"`

	// ShardTemplate is the configuration used for each equal-sized shard.
	// If you need shards that don't all share the same configuration,
	// use custom partitioning instead.
	ShardTemplate VitessShardTemplate `json:"shardTemplate,omitempty"`
}

// VitessKeyspaceCustomPartitioning lets you explicitly specify the key range of every shard.
type VitessKeyspaceCustomPartitioning struct {
	// Shards is a list of explicit shard specifications.
	// +patchMergeKey=keyRange
	// +patchStrategy=merge
	Shards []VitessKeyspaceKeyRangeShard `json:"shards" patchStrategy:"merge" patchMergeKey:"keyRange"`
}

// VitessKeyspaceKeyRangeShard defines a shard based on a key range.
type VitessKeyspaceKeyRangeShard struct {
	// KeyRange is the range of keys that this shard serves.
	//
	// WARNING: DO NOT change the key range of a shard after deploying.
	//          That's effectively deleting the old shard and adding a new one,
	//          which can lead to downtime or data loss. Instead, add an additional
	//          partitioning with the desired set of shards, perform a resharding
	//          migration, and then remove the old partitioning.
	KeyRange VitessKeyRange `json:"keyRange"`

	// VitessShardTemplate is the configuration for the shard.
	VitessShardTemplate `json:",inline"`
}

// VitessKeyRange specifies a range of keyspace IDs.
type VitessKeyRange struct {
	// Start is a lowercase hexadecimal string representation of an arbitrary-length sequence of bytes.
	// If Start is the empty string, the key range is unbounded at the bottom.
	// If Start is not empty, the bytes of a keyspace ID must compare greater
	// than or equal to Start in lexicographical order to be in the range.
	// +kubebuilder:validation:Pattern=^([0-9a-f][0-9a-f])*$
	Start string `json:"start,omitempty"`
	// End is a lowercase hexadecimal string representation of an arbitrary-length sequence of bytes.
	// If End is the empty string, the key range is unbounded at the top.
	// If End is not empty, the bytes of a keyspace ID must compare strictly less than End in
	// lexicographical order to be in the range.
	// +kubebuilder:validation:Pattern=^([0-9a-f][0-9a-f])*$
	End string `json:"end,omitempty"`
}

// VitessKeyspaceStatus defines the observed state of a VitessKeyspace.
// +k8s:openapi-gen=true
type VitessKeyspaceStatus struct {
	// The generation observed by the controller.
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// Shards is a summary of the status of all desired shards.
	Shards map[string]*VitessKeyspaceShardStatus `json:"shards,omitempty"`
	// OrphanedShards is a list of unwanted shards that could not be turned down.
	OrphanedShards map[string]*OrphanStatus `json:"orphanedShards,omitempty"`
	// Idle is a condition indicating whether the keyspace can be turned down.
	// If Idle is True, the keyspace is not deployed in any cells, so it should
	// be safe to turn down the keyspace.
	Idle corev1.ConditionStatus `json:"idle,omitempty"`
}

// NewVitessKeyspaceStatus creates a new status object with default values.
func NewVitessKeyspaceStatus() VitessKeyspaceStatus {
	return VitessKeyspaceStatus{
		Shards:         make(map[string]*VitessKeyspaceShardStatus),
		OrphanedShards: make(map[string]*OrphanStatus),
		Idle:           corev1.ConditionUnknown,
	}
}

// VitessKeyspaceShardStatus is the status of a shard within a keyspace.
type VitessKeyspaceShardStatus struct {
	// HasMaster is a condition indicating whether the Vitess topology
	// reflects a master for this shard.
	HasMaster corev1.ConditionStatus `json:"hasMaster,omitempty"`
	// DesiredTablets is the number of desired tablets. This is computed from
	// information that's already available in the spec, but clients should
	// use this value instead of trying to compute shard partitionings on their
	// own.
	DesiredTablets int32 `json:"desiredTablets,omitempty"`
	// Tablets is the number of observed tablets. This could be higher or
	// lower than desiredTablets if the state has not yet converged.
	Tablets int32 `json:"tablets,omitempty"`
	// ReadyTablets is the number of desired tablets that are Ready.
	ReadyTablets int32 `json:"readyTablets,omitempty"`
	// UpdatedTablets is the number of desired tablets that are up-to-date
	// (have no pending changes).
	UpdatedTablets int32 `json:"updatedTablets,omitempty"`
	// PendingChanges describes changes to the shard that will be applied
	// the next time a rolling update allows.
	PendingChanges string `json:"pendingChanges,omitempty"`
	// Cells is a list of cells in which any tablets for this shard are deployed.
	Cells []string `json:"cells,omitempty"`
}

// NewVitessKeyspaceShardStatus creates a new status object with default values.
func NewVitessKeyspaceShardStatus(spec *VitessKeyspaceKeyRangeShard) *VitessKeyspaceShardStatus {
	desiredTablets := int32(0)
	for tpIndex := range spec.TabletPools {
		desiredTablets += spec.TabletPools[tpIndex].Replicas
	}

	return &VitessKeyspaceShardStatus{
		HasMaster:      corev1.ConditionUnknown,
		DesiredTablets: desiredTablets,
	}
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// VitessKeyspaceList contains a list of VitessKeyspace
type VitessKeyspaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VitessKeyspace `json:"items"`
}

func init() {
	SchemeBuilder.Register(&VitessKeyspace{}, &VitessKeyspaceList{})
}
